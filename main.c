#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//defining macros
#define rows 9
#define columns 9
#define boxNum 9
#define totalSquares 81

#define Levels 3
#define Easy 10
#define Medium 15
#define Hard 25

//ansi code for coloring, if you are a windows user and coloring isn't working like it should, try to run
// this cmd command(as administrator):$ reg add HKEY_CURRENT_USER\Console /v VirtualTerminalLevel /t REG_DWORD /d 0x00000001 /f $
//(the dollar sign is excluded of course.)
#define COLOR_RED     "\x1b[31m"
#define COLOR_GREEN   "\x1b[32m"
#define COLOR_YELLOW  "\x1b[33m"
#define COLOR_BLUE    "\x1b[34m"
#define COLOR_MAGENTA "\x1b[35m"
#define COLOR_CYAN    "\x1b[36m"
#define COLOR_RESET   "\x1b[0m"

//*****************************************************************//
//define a struct to be used to track moves.
typedef struct
{
    int row;
    int col;
    int number;
} KeepMoves;
//***************************************************************//
//global variables
char sudokugrid[rows][columns]= {};
short rowMask[rows]= {}; //we have 9 rows, so each short number will represent a row (bit masking for the first 9 bits of short)
short columnMask[columns]= {}; //we have 9 columns, so each short number will represent a column (bit masking for the first 9 bits of short)
short boxMask[boxNum]= {}; //we have 9 boxes, so each short number will represent a box (bit masking for the first 9 bits of short)
int difficulty[Levels]= {Easy,Medium,Hard};
int level;
int moves=0; //this will be used as a reference to undo moves in order.
//maxNum+1 to ease calculations as we are dealing with numbers in range 1-9, so it's easier to use 1-indexed array
KeepMoves undoMoves[totalSquares]= {};

//***************************************************************************************//
//functions

//checking avilablity functions.
char avilableInRow(int i,int num)
{
    return !(1&rowMask[i]>>num);
}
char avilableInCol(int j,int num)
{
    return !(1&columnMask[j]>>num);
}
char avilableInBox(int index,int num)
{
    return !(1&boxMask[index]>>num);
}
//****************************************************************************************//
//generate index of box function
int boxIndex(int i,int j)
{
    if(i<3)
    {
        i=0;
    }
    else if(i<6)
    {
        i=3;
    }
    else
    {
        i=6;
    }
    if(j<3)
    {
        j=0;
    }
    else if(j<6)
    {
        j=1;
    }
    else
    {
        j=2;
    }
    return i+j;
}
//****************************************************************************************//
//generate puzzle

//first we will generate a random filled grid using bit-masking and back track algorithm to ensure that the problem is solvable
int fillGrid(int i,int j)
{
    //recursion conditions
    if(i==rows-1 && j==columns)
    {
        return 1;
    }
    if(j==columns)
    {
        j=0;
        i++;
    }
    if(sudokugrid[i][j])
    {
        return fillGrid(i,j+1);
    }
    // filling the grid with random numbers following sudoku rules.
    char num,lower = 1, upper = 9,counter=0;
    srand(time(0));
    short tried=0; //a bit mask for the numbers(possibilities) we tried.
    int index= boxIndex(i,j);
    while(counter<9)  //this counter will make us know when all the numbers are tried.
    {
        num = (rand() % (upper - lower + 1)) + lower;
        if(avilableInRow(i,num) && avilableInCol(j,num) && avilableInBox(index,num) && !(1& tried>>num))
        {
            sudokugrid[i][j]=num+'0';
            counter++;
            rowMask[i]=rowMask[i] | (1<<num); //marking that this number has been used in this row for future inputs.
            columnMask[j]=columnMask[j] | (1<<num); //marking that this number has been used in this column for future inputs.
            boxMask[index]=boxMask[index] | (1<<num);//marking that this number has been used in this box for future inputs.
            tried=tried|(1<<num);
            if(fillGrid(i,j+1))
            {
                return 1;
            }
            //else, we remove the number from each bitmask and search for another number that may hold.
            rowMask[i]&=~(1<<num);
            columnMask[j]&=~(1<<num);
            boxMask[index]&=~(1<<num);
        }
        else if(!(1& tried>>num))  //we have to make sure that all numbers from 1-9 were generated by our random number generator, whether it
        {
            //satisfies the above condition or not is a different story.
            tried=tried|(1<<num);
            counter++;
        }
        sudokugrid[i][j]=0;
    }
    return 0;
}

// remove some random indices depending on the difficulty level chosen by the user.
void removeFromGrid(int level)
{
    int i,j,lower = 0, upper = 8;
    srand(time(0));
    for(int removed=0; removed<level;)
    {
        i=(rand() % (upper - lower + 1)) + lower; //generate random row index
        j=(rand() % (upper - lower + 1)) + lower; //generate random column index
        if(sudokugrid[i][j]!=' ') //making sure the chosen random square hasn't been already removed.
        {
            char num=sudokugrid[i][j]-'0';
            int index= boxIndex(i,j);
            rowMask[i]&=~(1<<num);
            columnMask[j]&=~(1<<num);
            boxMask[index]&=~(1<<num);
            sudokugrid[i][j]=' ';
            removed++;
        }
    }
}
//**********************************************************************//
//printing function

void printStart(void)
{
    printf(COLOR_GREEN "1-Easy\n" COLOR_YELLOW "2-Medium\n" COLOR_RED "3-Hard\n" COLOR_RESET);
    printf("Enter the number corresponding to the difficulty level you want:\n");
}
void printingGrid(void)
{
    for(int i=0; i<rows; i++)
    {
        for(int stars=0; stars<3; stars++)
        {
            if(i==0 || i==3 || i==6)
            {
                printf(COLOR_MAGENTA "  **************** " COLOR_RESET);
            }
        }
        printf("\n");
        for(int j=0; j<columns; j++)
        {
            if(j==0 || j==3 || j==6)
            {
                printf(COLOR_CYAN "  !  " COLOR_RESET);
            }
            else
            {
                printf(COLOR_CYAN "  |  " COLOR_RESET );
            }

            printf(COLOR_YELLOW "%c" COLOR_RESET,sudokugrid[i][j]);
        }
        printf(COLOR_CYAN "  !\n" COLOR_RESET);
    }
    for(int stars=0; stars<3; stars++)
    {
        printf(COLOR_MAGENTA "  **************** " COLOR_RESET);
    }
}
void clearConsole(void)
{
    // this function clears the console then print the grid once again.
    printf("\e[1;H\e[2J"); //clear console
    printingGrid();
    printf("\n");
}
//****************************************************************************************//
//undo function.
void undo(void)
{
    if(moves==0)
    {
        clearConsole();
        printf(COLOR_RED "There are no moves to be undone.\n" COLOR_RESET);
    }
    else
    {
        KeepMoves pre=undoMoves[moves-1];
        sudokugrid[pre.row][pre.col]=' ';
        //we need to clear the bit in the row, column and box masks then decrement the number of moves.
        rowMask[pre.row] = rowMask[pre.row]& (~(1<<pre.number));
        columnMask[pre.col] = columnMask[pre.col]& (~(1<<pre.number));
        int index=boxIndex(pre.row,pre.col);
        boxMask[index] = boxMask[index]& (~(1<<pre.number));
        moves--;
        clearConsole();
    }
}

//************************************************************//
//functions to check users input

int checkAvailableSquare(int row, int col)
{
    if(sudokugrid[row][col]==' ')
    {
        return 1;
    }
    return 0;
}
int checkNumber(int row, int col,int num, int* flagOut)
{
    *flagOut=0; //the flag will be passed to other functions to determine the type of error and the suitable message to print.
    if(num>9 || num<1 )
    {
        *flagOut=1;
        return 0;
    }
    else if(avilableInCol(col,num) && avilableInRow(row,num) && avilableInBox(boxIndex(row,col),num))
    {
        rowMask[row]=rowMask[row] | (1<<num); //marking that this number has been used in this row for future inputs.
        columnMask[col]=columnMask[col] | (1<<num); //marking that this number has been used in this column for future inputs.
        boxMask[boxIndex(row,col)]=boxMask[boxIndex(row,col)] | (1<<num); //marking that this number has been used in this box for future inputs.
        return 1;
    }
    else
    {
        return 0;
    }
}

//***********************************************************//
//Handling invalid inputs functions
void invalidDim(void)
{
    clearConsole();
    printf(COLOR_RED "Invalid Input, " COLOR_RESET);
    printf("Row and column must be between 1-9 \n");
}
void invalidNum(int flagOut,int row, int col, int num)
{
    clearConsole();
    if(flagOut)
    {
        printf(COLOR_RED "Invalid Input, " COLOR_RESET);
        printf("Number must be between 1 and 9\n");
    }
    else
    {
        if(!avilableInRow(row,num))
        {
            printf(COLOR_RED "Wrong answer, The number already exists in row\n" COLOR_RESET);
        }
        else if(!avilableInCol(col,num))
        {
            printf(COLOR_RED "Wrong answer, The number already exists in column\n" COLOR_RESET);
        }
        else
        {
            printf(COLOR_RED "Wrong answer, The number already exists in block\n" COLOR_RESET);
        }
    }
}
//*********************************************************//
//asking user for inputs
void askUserToEnterDifficulty(void)
{
    int success;
    success=scanf("%d",&level);
    if(level>3 || level<1)
    {
        if(success!=1){scanf("%*[^\n]%*c");}//if the user entered a letter or anything other than a number.
        printf("\e[1;H\e[2J"); //clear console
        printStart();
        printf(COLOR_RED "Invalid Input, " COLOR_RESET "choose number between 1-3\n");
        askUserToEnterDifficulty();
        return;
    }
    level--;
}
void askUserToEnterDim(int* row, int* col)
{
    int flagWork=1;
    clearConsole();
    while(flagWork)
    {
        printf(COLOR_CYAN "Please enter row and column (from 1x1 to 9x9), " COLOR_RESET);
        printf(COLOR_GREEN "OR ENTER -1 TO UNDO LAST MOVE\n" COLOR_RESET);
        int success=scanf("%d",row);
        if(success!=1){
            scanf("%*[^\n]%*c");//if the user entered a letter or anything other than a number.
            invalidDim();
        }
        else if((*row)==-1)
        {
            undo();
        }
        else
        {
            success=scanf("%d",col);
            if(success!=1){ //if the user entered a letter or anything other than a number.
                scanf("%*[^\n]%*c");
                invalidDim();
            }
            else if(*row<=0 || *row>9 || *col<=0 || *col>9)
            {
                invalidDim();
            }
            else if(!checkAvailableSquare(*row -1,*col -1))
            {
                clearConsole();
                printf(COLOR_RED "Invalid input, " COLOR_RESET);
                printf("This is not an empty square.\n");
            }
            else
            {
                *row = (*row)-1;
                *col = (*col)-1;
                flagWork=0;
            }
        }
    }
}
void askUserToEnterNumber(int* row, int* col)
{
    int flagOut=0,flagWork=1;
    int number;
    clearConsole();
    while(flagWork)
    {
        printf(COLOR_CYAN "Enter a number Between 1-9, " COLOR_GREEN "Or Enter 0 to return \n" COLOR_RESET);
        int success=scanf("%d",&number);
        if(success!=1){ //if the user entered a letter or anything other than a number.
            scanf("%*[^\n]%*c");
            invalidNum(1,*row,*col,number);
        }
        else if(checkNumber(*row,*col,number,&flagOut))
        {
            sudokugrid[*row][*col]=(char)number+'0';
            //we need to record this move in our keepMoves array, so the user can undo later on if he wanted.
            KeepMoves currentMove;
            currentMove.row=*row;
            currentMove.col=*col;
            currentMove.number= number;
            undoMoves[moves]=currentMove;
            flagWork=0;
        }
        else if(number==0)
        {
            askUserToEnterDim(row,col);
        }
        else
        {
            invalidNum(flagOut,*row,*col,number);
        }
    }
}
//***********************************************************************************//
//startGame function
void startGame(void)
{
    int row=0,col=0;
    fillGrid(row,col);
    printStart();
    askUserToEnterDifficulty();
    removeFromGrid(difficulty[level]);
    while(moves<difficulty[level])
    {
        askUserToEnterDim(&row,&col);
        askUserToEnterNumber(&row,&col);
        moves++;
    }
    clearConsole();
    printf("Congrats!!\n");
}
//******************************************************************************//
//main function.
int main()
{
    startGame();

    return 0;
}
